<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quick Copy</title>
  <style>
    :root {
      --base-font: clamp(7px, 2vh + 10px, 18px);
      --cell-font: clamp(5px, calc(var(--cell-size) * 0.5), 40px);
      --bg-color: #f0f0f0;
      --text-color: #111;
      --surface-color: #ffffff;
      --button-border: #ccc;
      --button-bg: #ffffff;
      --button-hover: #e0e0e0;
      --button-active: #d0d0d0;
      --button-selected: #b5b5b5;
      --button-text-color: #111;
      --toast-bg: #333333;
      --toast-color: #f5f5f5;
      --column-count: 5;
      --cell-size: 64px;
    }

    :root[data-theme="dark"] {
      --bg-color: #0f1115;
      --text-color: #f5f5f5;
      --surface-color: #1c1f26;
      --button-border: #3a3f4b;
      --button-bg: #343c4a;
      --button-hover: #475164;
      --button-active: #161920;
      --button-selected: #68738d;
      --button-text-color: #ffffff;
      --toast-bg: #f5f5f5;
      --toast-color: #111111;
    }

    body {
      font-family: sans-serif;
      font-size: var(--base-font);
      margin: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 0.5rem;
      box-sizing: border-box;
      max-width: 100%;
    }

    table {
      border-collapse: collapse;
      table-layout: fixed;
      width: calc(var(--cell-size) * var(--column-count));
      max-width: 100%;
    }

    td {
      width: var(--cell-size);
      height: var(--cell-size);
      max-width: calc(90vw / var(--column-count));
      box-sizing: border-box;
      min-width: 0;
      padding: 3px;
    }

    .key-wrapper {
      position: relative;
      height: var(--cell-size);
    }

    .copy-btn,
    .edit-input {
      width: 100%;
      height: 100%;
    }

    .copy-btn {
      font-size: var(--cell-font);
      padding: 0.2rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      line-height: 1;
      box-sizing: border-box;
      overflow: hidden;
      cursor: pointer;
      background: var(--button-bg);
      border: 1px solid var(--button-border);
      color: var(--button-text-color);
      border-radius: 5px;
      font-family: monospace;
      transition: background 0.3s ease, transform 0.1s ease;
    }

    .copy-btn:hover {
      background: var(--button-hover);
      transform: scale(1.05);
    }

    .copy-btn:active {
      background: var(--button-active);
      transform: scale(0.95);
    }

    .copy-btn.selected {
      background: var(--button-selected);
    }

    .copy-btn.blank {
      cursor: default;
      pointer-events: none;
      opacity: 0.45;
      border-style: dashed;
    }

    .edit-input {
      display: none;
      padding: 0.25rem;
      border-radius: 4px;
      border: 1px solid var(--button-border);
      background: var(--surface-color);
      color: var(--text-color);
      text-align: center;
      font-family: monospace;
      font-size: var(--cell-font);
      box-sizing: border-box;
      line-height: 1;
    }

    .copy-btn.size-30,
    .edit-input.size-30 {
      font-size: calc(var(--cell-font) * 0.7);
    }

    .copy-btn.size-60,
    .edit-input.size-60 {
      font-size: calc(var(--cell-font) * 0.4);
    }

    .config-mode .copy-btn {
      display: none;
    }

    .config-mode .edit-input {
      display: block;
    }

    .controls {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      width: 100%;
    }

    .column-config {
      display: none;
      align-items: center;
      gap: 0.35rem;
    }

    .column-config label {
      font-size: 0.65rem;
    }

    .column-config input[type="number"] {
      width: 1.9rem;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      border: 1px solid var(--button-border);
      background: var(--surface-color);
      color: var(--text-color);
      font-family: monospace;
    }

    .config-mode .column-config {
      display: inline-flex;
    }

    .config-only {
      display: none;
    }

    .config-mode .config-only {
      display: inline-flex;
    }

    #configureBtn,
    #resetBtn,
    #themeToggle {
      background: var(--button-bg);
      border: 1px solid var(--button-border);
      color: var(--button-text-color);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    #configureBtn:hover,
    #resetBtn:hover,
    #themeToggle:hover {
      background: var(--button-hover);
    }

    @keyframes fadeHighlight {
      0% {
        background: #cfe5ff;
      }

      100% {
        background: white;
      }
    }

    .toast {
      position: fixed;
      background: var(--toast-bg);
      color: var(--toast-color);
      padding: 10px 20px;
      border-radius: 4px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
      z-index: 1000;
    }

    .toast.show {
      opacity: 1;
    }
  </style>
</head>

<body>
  <table id="charGrid">
    <tbody></tbody>
  </table>
  <div class="controls" id="controls">
    <button id="configureBtn" type="button">⚙️</button>
    <div class="column-config" id="columnConfig">
      <label for="rowInput">rows:</label>
      <input id="rowInput" type="number" min="1" max="20" inputmode="numeric" aria-label="Rows">
      <label for="columnInput">cols:</label>
      <input id="columnInput" type="number" min="1" max="20" inputmode="numeric" aria-label="Columns">
      <button id="themeToggle" type="button" aria-pressed="false">Dark</button>
      <button id="resetBtn" type="button">Reset</button>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script>
    const storageKey = 'copychars.characters';
    const columnStorageKey = 'copychars.columns';
    const rowStorageKey = 'copychars.rows';
    const themeStorageKey = 'copychars.theme';
    const root = document.documentElement;
    const configureBtn = document.getElementById('configureBtn');
    const controlsPanel = document.getElementById('controls');
    const charGrid = document.getElementById('charGrid');
    const columnInput = document.getElementById('columnInput');
    const rowInput = document.getElementById('rowInput');
    const parseCssFloat = (value) => Number.isFinite(Number.parseFloat(value ?? '')) ? Number.parseFloat(value) : 0;
    const defaultCharacters = [
      '`', '^', '{', '}', '[', ']', ';', ':', '"', '|',
      '\\', '$', '(', ')', '<', '>', '¿', '?',
      '#', '&', '*', '=', '~', '_', '/',
    ];
    const defaultColumns = 5;
    const defaultRows = Math.ceil(defaultCharacters.length / defaultColumns);
    const focusableSelector = 'a[href], area[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])';
    let characters = loadCharacters();
    let columns = loadColumns();
    let rows = loadRows();
    let configureMode = false;
    const gridBody = document.querySelector('#charGrid tbody');
    const themeToggleBtn = document.getElementById('themeToggle');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    characters = normalizeCharacterGrid(characters, columns, rows);
    setColumnCount(columns);
    syncGridInputs();
    applyTheme(loadTheme());
    themeToggleBtn.addEventListener('click', toggleTheme);
    prefersDark.addEventListener('change', ({ matches }) => {
      if (localStorage.getItem(themeStorageKey)) return;
      applyTheme(matches ? 'dark' : 'light');
    });
    window.addEventListener('resize', () => updateCellSize());
    renderGrid(characters);

    function loadCharacters() {
      const saved = localStorage.getItem(storageKey);
      if (saved) {
        try {
          const parsed = JSON.parse(saved);
          if (Array.isArray(parsed)) {
            return parsed.map(String);
          }
        } catch (err) {
          console.warn('Failed to parse saved characters.', err);
        }
      }
      return [...defaultCharacters];
    }

    function loadColumns() {
      const saved = Number.parseInt(localStorage.getItem(columnStorageKey) ?? '', 10);
      if (Number.isFinite(saved) && saved > 0) return saved;
      return defaultColumns;
    }

    function loadRows() {
      const saved = Number.parseInt(localStorage.getItem(rowStorageKey) ?? '', 10);
      if (Number.isFinite(saved) && saved > 0) return saved;
      return Math.max(1, Math.ceil(characters.length / columns));
    }

    function normalizeCharacterGrid(values, columnCount, rowCount) {
      const totalCells = Math.max(1, columnCount * rowCount);
      const normalized = values.slice(0, totalCells);
      while (normalized.length < totalCells) {
        normalized.push('');
      }
      return normalized;
    }

    function renderGrid(list) {
      gridBody.innerHTML = '';
      list.forEach((char, idx) => {
        if (idx % columns === 0) {
          gridBody.appendChild(document.createElement('tr'));
        }

        const cell = document.createElement('td');
        const wrapper = document.createElement('div');
        wrapper.className = 'key-wrapper';
        wrapper.dataset.index = idx;

        const sizeClass = getLengthSizeClass(char);
        const btn = document.createElement('button');
        const isBlank = char === '';
        btn.className = ['copy-btn', isBlank ? 'blank' : null, sizeClass].filter(Boolean).join(' ');
        btn.textContent = isBlank ? '\u200B' : char;
        btn.dataset.index = idx;
        btn.addEventListener('keydown', handleButtonArrowNav);
        btn.onclick = (e) => {
          if (isBlank) return;
          copyChar(char, e);
        };
        if (isBlank) {
          btn.setAttribute('aria-disabled', 'true');
        }
        wrapper.appendChild(btn);

        const input = document.createElement('input');
        input.type = 'text';
        input.className = `edit-input${sizeClass ? ` ${sizeClass}` : ''}`;
        input.dataset.index = idx;
        input.value = char;
        input.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            const nextIndex = (idx + 1) % characters.length;
            focusSiblingInput(nextIndex);
          } else if (event.key === 'ArrowUp') {
            event.preventDefault();
            const nextIndex = idx - columns < 0 ? getWrapIndex(idx, false) : idx - columns;
            focusSiblingInput(nextIndex);
          } else if (event.key === 'ArrowDown') {
            event.preventDefault();
            const nextIndex = idx + columns >= characters.length ? getWrapIndex(idx, true) : idx + columns;
            focusSiblingInput(nextIndex);
          }
        });
        wrapper.appendChild(input);
        cell.appendChild(wrapper);
        gridBody.lastElementChild.appendChild(cell);
      });
      syncConfigureState();
      updateCellSize();
    }

    configureBtn.addEventListener('click', configureCharacters);
    document.getElementById('resetBtn').addEventListener('click', resetCharacters);

    function configureCharacters() {
      if (!configureMode) {
        configureMode = true;
        syncConfigureState();
        syncGridInputs();
        //focusFirstInput();
        return;
      }

      if (saveAllEdits()) {
        configureMode = false;
        syncConfigureState();
      }
    }

    function syncConfigureState() {
      document.body.classList.toggle('config-mode', configureMode);
      if (configureBtn) {
        configureBtn.textContent = configureMode ? 'Done' : '⚙️';
      }
    }

    function focusFirstInput() {
      const firstInput = document.querySelector('.edit-input');
      if (!firstInput) return;
      requestAnimationFrame(() => {
        firstInput.focus();
        firstInput.select();
      });
    }

    function focusSiblingInput(index) {
      const sibling = document.querySelector(`.edit-input[data-index="${index}"]`);
      if (sibling) {
        sibling.focus();
        sibling.select();
      }
    }

    function saveAllEdits() {
      const inputs = Array.from(document.querySelectorAll('.edit-input'));
      if (!inputs.length) return true;
      const nextValues = inputs
        .sort((a, b) => Number(a.dataset.index) - Number(b.dataset.index))
        .map(input => input.value);

      const nextColumns = readColumnInput();
      const nextRows = readRowInput();
      const dimensions = [
        { value: nextColumns, name: 'columns', input: columnInput },
        { value: nextRows, name: 'rows', input: rowInput }
      ];

      for (const { value, name, input } of dimensions) {
        if (!Number.isFinite(value) || value < 1) {
          alert(`Please enter a valid number of ${name}.`);
          input?.focus();
          return false;
        }
      }

      characters = nextValues;
      columns = nextColumns;
      rows = nextRows;
      characters = normalizeCharacterGrid(characters, columns, rows);
      localStorage.setItem(storageKey, JSON.stringify(characters));
      localStorage.setItem(columnStorageKey, String(columns));
      localStorage.setItem(rowStorageKey, String(rows));
      setColumnCount(columns);
      renderGrid(characters);
      syncGridInputs();
      return true;
    }

    function readColumnInput() {
      if (!columnInput) return columns;
      const parsed = Number.parseInt(columnInput.value ?? '', 10);
      if (!Number.isFinite(parsed)) return NaN;
      return Math.min(20, Math.max(1, parsed));
    }

    function readRowInput() {
      if (!rowInput) return rows;
      const parsed = Number.parseInt(rowInput.value ?? '', 10);
      if (!Number.isFinite(parsed)) return NaN;
      return Math.min(20, Math.max(1, parsed));
    }

    function syncGridInputs() {
      if (columnInput) {
        columnInput.value = columns;
      }
      if (rowInput) {
        rowInput.value = rows;
      }
    }

    function setColumnCount(count) {
      columns = count;
      root.style.setProperty('--column-count', columns);
    }

    function updateCellSize() {
      const rowCount = rows;
      const gridTop = charGrid?.getBoundingClientRect().top ?? 0;
      const controlsHeight = controlsPanel?.getBoundingClientRect().height ?? 0;
      const bodyStyles = window.getComputedStyle(document.body);
      const layoutGap = parseCssFloat(bodyStyles.rowGap) || parseCssFloat(bodyStyles.gap);
      const bottomPadding = parseCssFloat(bodyStyles.paddingBottom);
      const availableHeight = Math.max(window.innerHeight - gridTop - controlsHeight - layoutGap - bottomPadding, 80);
      const rowOverhead = getRowOverhead();
      const sizeFromHeight = (availableHeight - rowOverhead * rowCount) / rowCount;
      const maxSize = 200;
      const minSize = 36;
      const finalSize = Math.max(minSize, Math.min(sizeFromHeight, maxSize));
      root.style.setProperty('--cell-size', `${finalSize}px`);
    }

    function getRowOverhead() {
      const sampleCell = charGrid?.querySelector('td');
      if (!sampleCell) return 0;
      const computed = window.getComputedStyle(sampleCell);
      return parseCssFloat(computed.paddingTop)
        + parseCssFloat(computed.paddingBottom)
        + parseCssFloat(computed.borderTopWidth)
        + parseCssFloat(computed.borderBottomWidth);
    }

    function resetCharacters() {
      if (!confirm('Are you sure to reset?')) return;
      localStorage.removeItem(storageKey);
      localStorage.removeItem(columnStorageKey);
      localStorage.removeItem(rowStorageKey);
      characters = [...defaultCharacters];
      columns = defaultColumns;
      rows = defaultRows;
      characters = normalizeCharacterGrid(characters, columns, rows);
      setColumnCount(columns);
      syncGridInputs();
      renderGrid(characters);
    }

    function copyChar(char, event) {
      const target = event?.currentTarget;
      navigator.clipboard.writeText(char).then(() => {
        highlightButton(target);
        showToast(`copied`, event.clientX, event.clientY);
      }).catch(err => {
        console.error('Failed to copy: ', err);
      });
    }

    let btnHilite = null;
    function highlightButton(btn) {
      if (btnHilite) {
        btnHilite.classList.remove('selected');
      }
      btnHilite = btn;
      if (!btn) return;
      btn.classList.add('selected');
    }

    function showToast(message, x, y) {
      const toast = document.getElementById('toast');
      toast.innerHTML = message;
      // Position tooltip slightly offset from the cursor
      toast.style.left = (x + 15) + 'px';
      toast.style.top = (y + 15) + 'px';
      toast.classList.add('show');
      setTimeout(() => {
        toast.classList.remove('show');
      }, 300);
    }

    function handleButtonArrowNav(event) {
      const { key, currentTarget } = event;
      if (!['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(key)) return;
      event.preventDefault();
      const index = Number(currentTarget?.dataset.index);
      if (Number.isNaN(index)) return;

      let nextIndex = index;
      switch (key) {
        case 'ArrowLeft':
          if (index % columns === 0) {
            moveFocusByTab(currentTarget, false);
            return;
          }
          nextIndex = index - 1;
          break;
        case 'ArrowRight':
          if (index % columns === columns - 1 || index + 1 >= characters.length) {
            moveFocusByTab(currentTarget, true);
            return;
          }
          nextIndex = index + 1;
          break;
        case 'ArrowUp':
          if (index < columns) {
            nextIndex = getWrapIndex(index, false);
          } else {
            nextIndex = index - columns;
          }
          break;
        case 'ArrowDown':
          if (index + columns >= characters.length) {
            nextIndex = getWrapIndex(index, true);
          } else {
            nextIndex = index + columns;
          }
          break;
      }

      const nextBtn = gridBody.querySelector(`button[data-index="${nextIndex}"]`);
      nextBtn?.focus();
    }

    function moveFocusByTab(current, forward) {
      const focusables = Array.from(document.querySelectorAll(focusableSelector));
      const position = focusables.indexOf(current);
      if (position === -1) return;
      const next = focusables[position + (forward ? 1 : -1)];
      next?.focus();
    }

    function getWrapIndex(index, forward) {
      const column = index % columns;
      if (forward) return column;
      let wrapped = column;
      while (wrapped + columns < characters.length) {
        wrapped += columns;
      }
      return wrapped;
    }

    function loadTheme() {
      const stored = localStorage.getItem(themeStorageKey);
      if (stored === 'light' || stored === 'dark') return stored;
      return prefersDark.matches ? 'dark' : 'light';
    }

    function applyTheme(mode) {
      root.dataset.theme = mode;
      if (!themeToggleBtn) return;
      const isDark = mode === 'dark';
      themeToggleBtn.textContent = isDark ? 'Light' : 'Dark';
      themeToggleBtn.setAttribute('aria-pressed', String(isDark));
    }

    function toggleTheme() {
      const next = root.dataset.theme === 'dark' ? 'light' : 'dark';
      localStorage.setItem(themeStorageKey, next);
      applyTheme(next);
    }

    function getLengthSizeClass(value) {
      const str = value ?? '';
      const words = str.split(/\s+/).filter(w => w.length > 0);
      const maxWordLength = words.length > 0 ? Math.max(...words.map(word => word.length)) : 0;
      const len = maxWordLength;
      
      if (len > 80) return 'size-60';
      if (len >= 5) return 'size-60';
      if (len >= 3) return 'size-30';
      return '';
    }
  </script>
</body>
</html>
